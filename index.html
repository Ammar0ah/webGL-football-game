<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
		<title>therd test three.js app</title>
        <style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
    </head>
    
    <body>
        <div id="scene"></div>

        <script src="node_modules/three/build/three.js"></script>
		<script src="node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
        <script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
        <script src="node_modules/three/examples/js/objects/Sky.js"></script>
        <script src="node_modules/three/examples/js/libs/dat.gui.min.js"></script>
        <script src="node_modules/three/examples/js/controls/PointerLockControls.js"></script>

<!--        <script src="node_modules/three/examples/js/loaders/OBJLoader.js"></script>-->

        <script>
            let scene,
                renderer,
                container,
                width,
                height;
            let camera,
                controls,
                fov, aspect, near, far;
            let Playermixer,clock,ready=false;
            
            let raycaster,playerContols;

			let moveForward = false;
			let moveBackward = false;
			let moveLeft = false;
			let moveRight = false;
			let canJump = false;
            
			let velocity = new THREE.Vector3();
			let direction = new THREE.Vector3();
            
            let shape,shapeGeometry;
            
            init();
            
            animate();
            function init(){
                width = window.innerWidth;
                height = window.innerHeight;

                fov = 50;
                aspect = width / height;
                near = 1;
                far = 4000;

                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
                camera.position.set(50,150,-350);
                camera.lookAt(new THREE.Vector3(0,0,0));
                
                //controls = new THREE.PointerLockControls( camera );
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width,height);
                renderer.setClearColor( 0xfff6e6 );

                container = document.getElementById('scene');
                container.appendChild(renderer.domElement);
                
                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', function() { renderer.render(scene, camera); } );
                controls.staticMoving = true;
//                controls.minDistance = 100;
//                controls.maxDistance = 500;
//                controls.maxPolarAngle = (Math.PI / 2) - 0.1;

                lighting();
                plane();
                ball();
                wall();
                initSky();
                humantLoad();
                robotLoad();
                
                window.addEventListener( 'resize', onWindowResize, false );
                document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );
                clock= new THREE.Clock();
            }
            function plane(){
                // A mesh is created from the geometry and material, then added to the scene
                let groundTexture = new THREE.TextureLoader().load('img/grasslight-big.jpg');
                groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(25, 25);
                groundTexture.anisotropy = 16;
                let plane = new THREE.Mesh(
                    new THREE.PlaneGeometry( 3000,2000),
                    new THREE.MeshStandardMaterial( { 
                        map:groundTexture,
                    })
                );
                plane.rotateX(-Math.PI/2);
                plane.receiveShadow = true;
                plane.castShadow = true;

                scene.add( plane );
            }
            function ball() {
                let ballTexture = new THREE.TextureLoader().load('img/ballTexture.jpg');
                
                let sphere = new THREE.SphereGeometry(10, 10, 36);
                let material1 = new THREE.MeshLambertMaterial({ map: ballTexture });
                
                let ball = new THREE.Mesh(sphere, material1);
                ball.receiveShadow = true;
                ball.castShadow = true;
                ball.position.y += 50;
                ball.position.z += 200;
                ball.position.set(0,15,100);
                
                renderer.shadowMap.enabled = true;
                scene.add(ball);
            }
            function wall(){
                let skyBox = new THREE.BoxGeometry(3000,1000,2000);
                let materials = 
                [
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('img/footballwall.jpg') ,side :THREE.DoubleSide}),
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('img/footballwall.jpg') ,side :THREE.DoubleSide}),
                    new THREE.MeshBasicMaterial( { transparent: true, opacity: 0, wireframe: true, side: THREE.DoubleSide} ),
                    new THREE.MeshBasicMaterial( { transparent: true, opacity: 0, wireframe: true, side: THREE.DoubleSide} ),
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('img/footballwall.jpg') ,side :THREE.DoubleSide}),
                    new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load('img/footballwall.jpg') ,side :THREE.DoubleSide}),
//                    new THREE.MeshBasicMaterial( { transparent: true, opacity: 0, wireframe: true, side: THREE.DoubleSide} ),
                ]
                let faceMaterial = new THREE.MeshFaceMaterial(materials);
                let skyBoxMesh = new THREE.Mesh(skyBox , faceMaterial);
                skyBoxMesh.position.y = 400;
                scene.add(skyBoxMesh);
            }
            function initSky() {
                // Add Sky
                sky = new THREE.Sky();
                sky.scale.setScalar(450000);
                sky.position.z = -100;
                scene.add(sky);
                // Add Sun Helper
                sunSphere = new THREE.Mesh(
                    new THREE.SphereBufferGeometry(20000, 16, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                sunSphere.position.y = - 700000;
                sunSphere.visible = true;
                scene.add(sunSphere);
                /// GUI
                var effectController = {
                    turbidity: 10,
                    rayleigh: 2,
                    mieCoefficient: 0.005,
                    mieDirectionalG: 0.8,
                    luminance: 1,
                    inclination: 0.49, // elevation / inclination
                    azimuth: 0.25, // Facing front,
                    sun: ! true
                };
                var distance = 400000;
                function guiChanged() {
                    var uniforms = sky.material.uniforms;
                    uniforms.turbidity.value = effectController.turbidity;
                    uniforms.rayleigh.value = effectController.rayleigh;
                    uniforms.luminance.value = effectController.luminance;
                    uniforms.mieCoefficient.value = effectController.mieCoefficient;
                    uniforms.mieDirectionalG.value = effectController.mieDirectionalG;
                    var theta = Math.PI * (effectController.inclination - 0.5);
                    var phi = 2 * Math.PI * (effectController.azimuth - 0.5);
                    sunSphere.position.x = distance * Math.cos(phi);
                    sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
                    sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
                    sunSphere.rotation.y += 50;
                    sunSphere.visible = effectController.sun;
                    uniforms.sunPosition.value.copy(sunSphere.position);


                    renderer.render(scene, camera);


                }
                var gui = new dat.GUI();
                gui.add(effectController, "turbidity", 1.0, 20.0, 0.1).onChange(guiChanged);
                gui.add(effectController, "rayleigh", 0.0, 4, 0.001).onChange(guiChanged);
                gui.add(effectController, "mieCoefficient", 0.0, 0.1, 0.001).onChange(guiChanged);
                gui.add(effectController, "mieDirectionalG", 0.0, 1, 0.001).onChange(guiChanged);
                gui.add(effectController, "luminance", 0.0, 2).onChange(guiChanged);
                gui.add(effectController, "inclination", 0, 1, 0.0001).onChange(guiChanged);
                gui.add(effectController, "azimuth", 0, 1, 0.0001).onChange(guiChanged);
                gui.add(effectController, "sun").onChange(guiChanged);
                guiChanged();
		    }
            function lighting() {
              const light = new THREE.DirectionalLight( 0xdfebff, 1);
              light.position.set( -400, 1000, -400 );
              light.castShadow = true;

              const d = 200;
              light.shadowCameraLeft = -d;
              light.shadowCameraRight = d;
              light.shadowCameraTop = d;
              light.shadowCameraBottom = -d;

              light.shadowCameraFar = far;

              scene.add( light );
              scene.add( new THREE.HemisphereLight( 0xffffbb, 0x080820, 0.6 ) );
              scene.add( new THREE.AmbientLight(0xa59f75, 0.6) );
            }
            let Player;
            function robotLoad(){
                let loader = new THREE.GLTFLoader();
				loader.load( 'RobotExpressive/RobotExpressive.glb',function (gltf) {
                let object = gltf.scene;
                console.log(scene);
                    object.scale.set(10,10,10);
                    object.position.set(-40,0,20);
                    object.rotation.set(0,0.4,0);
                    Playermixer = new THREE.AnimationMixer( object );
                    console.log(gltf.animations.length);
                    let walk;
                    for(let i=0;i<gltf.animations.length;i++){
                        let clip=gltf.animations[i];
						if(clip.name === 'Walking'){
                            console.log("found");
                            walk=clip;
                        }
                    }
					let action = Playermixer.clipAction( walk );
					action.play();

                    playerContols = new THREE.PointerLockControls(object.getObjectByName( 'Root Scene' ) );
                    scene.add( playerContols.getObject() );
                    ready=true;
                    console.log(object);
                });

            }
            function humantLoad(){
                let loader = new THREE.GLTFLoader();
				loader.load( 'Animated Human by @Quaternius/Animated Human.glb',function (gltf) {
                    let object = gltf.scene;
                    let walk;
                    console.log(gltf.animations.length);
                    for(let i=0;i<gltf.animations.length;i++){
                        let clip=gltf.animations[i];
                        console.log(clip.name);
						if(clip.name === 'Walking'){
                            console.log("found");
                            walk=clip;
                        }
                    }
                    object.scale.set(10,10,10);
                    object.position.set(40,0,20);
					object.rotation.set(0,-0.4,0);
                    scene.add( object );
				});
            }
            
            function onWindowResize() {
				width = window.innerWidth;
				height = window.innerHeight;
                aspect=width/height;
				
                renderer.setSize( width, height );
				camera.aspect = aspect;
				camera.updateProjectionMatrix();
			}
            
            function onKeyDown ( event ) {

					switch ( event.keyCode ) {

//						case 38: // up
						case 87: // w
							moveForward = true;
							break;

//						case 37: // left
						case 65: // a
							moveLeft = true;
							break;

//						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

//						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 32: // space
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;

					}

				};
            
                function onKeyUp ( event ) {

					switch ( event.keyCode ) {

//						case 38: // up
						case 87: // w
							moveForward = false;
							break;

//						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

//						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

//						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

				};
            function animate(){
                requestAnimationFrame( animate );
                if(ready){
                    update();
                    render();
                }
            }
            function update(){
                delta = clock.getDelta() *2;
                let time = Date.now() * 0.05;
				Playermixer.update( delta *0.6 );
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

                direction.z =  Number( moveBackward ) - Number( moveForward ) ;
                direction.x =  Number( moveRight - Number( moveLeft ));
                direction.normalize(); // this ensures consistent movements in all directions

                if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
                if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;
                
                velocity.y = Math.max( 0, velocity.y );
                
                
                playerContols.getObject().translateX( velocity.x * delta );
                playerContols.getObject().translateY( velocity.y * delta );
                playerContols.getObject().translateZ( velocity.z * delta );
                camera.lookAt(playerContols.getObject().position);
//                console.log("cc: "+playerContols.getObject().position.x);
            } 
            function render(){
                renderer.render( scene, camera );
            }
            // for any test
            function getCube(){
                shape = new THREE.Mesh(
                    new THREE.BoxGeometry(100,100,100),
                    new THREE.MeshNormalMaterial()
                );
                shape.position.set(0,100,0);
                scene.add(shape); 
            }
        </script>
    </body>
</html>