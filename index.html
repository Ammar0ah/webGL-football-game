<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Football Player</title>
    <link rel="icon" href="Ball.png">    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    #scene{
            display: none;
        }
    
    .loading {
            display: block;
            width: 100%;
            min-height: 1000;
            background: #333;
            overflow: hidden;
        }
    .loading h5 {
        color: #fff;
        font-size: 50px;
        text-align: center;
        font-weight: bolder;
    }
    
    </style>
</head>

<body>
   <div class="loading" id="container"> <h5>loading...</h5> </div>
    <div id="scene"></div>

    <script src="node_modules/three/build/three.js"></script>
    <script src="node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
    <script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
    <script src="node_modules/three/examples/js/objects/Sky.js"></script>
    <script src="node_modules/three/examples/js/libs/dat.gui.min.js"></script>
    <script src="node_modules/three/examples/js/controls/PointerLockControls.js"></script>
    <script src="node_modules/three/examples/js/loaders/OBJLoader.js"></script>
    <script src="node_modules/three/examples/js/loaders/MTLLoader.js"></script>
    
<!--    my scripts-->
    <script src="js/hs.js"></script>
<!--    <script src="js/Stadium.js"></script>-->
    <script>
        let loading = document.getElementById("container");
        let body = document.getElementById("scene");
        function preloader() {
            loading.style.display = "none";
            body.style.display = "block";
        }
       window.onload = setTimeout(preloader, 2600);
        
        const eps=1e-3;
        let keyleft="A".charCodeAt(0);
        let keyright="D".charCodeAt(0);
        let keyup="W".charCodeAt(0);
        let keydown="S".charCodeAt(0);
        let keyspeed="E".charCodeAt(0);
        let scene,
            renderer,
            container,
            width,
            height,
            alpha =0.5,
            i=0;
        let camera,camera1,
            controls,
            ball,
            fov, aspect, near, far;
        let clock, ready = false;
        let mouseDown = false;

        let raycaster,collidableMeshList = [];
        let shape, shapeGeometry;
        let player;
        let supervisor;
        let dome;
        let Dome = function(){
            let model = this;
            this.mesh = new THREE.Object3D();
            this.ready=0;
            this.np=3;
            let loader;
            loader = new THREE.MTLLoader();            
            loader.load('models/wooden-coffe-table/wooden_coffe_table.mtl', function (material) {
                material.preload();
                let tableLoader = new THREE.OBJLoader();
                tableLoader.setMaterials(material);
                
                tableLoader.load('models/wooden-coffe-table/wooden_coffe_table.obj', function (object) {
                    object.scale.set(50, 50, 50);
                    object.traverse(function (node) {
                        if (node instanceof THREE.Mesh) { node.castShadow = true; node.receiveShadow =true; }
                    });
                    model.mesh.add(object);
                    model.ob1=object;
                    collidableMeshList.push(object);
                    model.ready++;
                });
             });

             loader = new THREE.OBJLoader();
             loader.load('models/vases/FreebieVases.obj', function(object){
//            alert(glltf);
//                 let objact = gltf.scene;
                 object.traverse(function (node) {
                       if (node instanceof THREE.Mesh) { 
                            node.castShadow = true;
                        }
                    });
                object.scale.set(0.1,0.1,0.1);
                object.position.y+=65;
                object.position.z+=10;
                 
                model.mesh.add(object);
                 model.ob2=object;
                 collidableMeshList.push(object);
//                 console.log(object);
                    model.ready++;
             });
             loader = new THREE.GLTFLoader();
             loader.load('models/groot_dancing_2/scene.gltf',function(gltf){
                 let object = gltf.scene;
                 object.scale.set(0.1,0.1,0.1);
                 object.position.set(-50,0,-850);
                 object.rotation.y=-Math.PI;
                 model.ob3 = object;
                 model.ob3mixer=new THREE.AnimationMixer(object);
                 
                 model.ob3action = model.ob3mixer.clipAction( gltf.animations[0] );
                 model.ob3action.play();
                 model.ready++;
                 scene.add(object);
                 collidableMeshList.push(object);
                 console.log(gltf)
             });
             this.mesh.position.set(20, 0, -850);
             scene.add(this.mesh);
             this.mesh.position.x+=100;
            //console.log(model);
        }
        let Ball = function(){
            this.Speed = 1000.0;
            this.RotationSpeed=Math.PI * 5;
            this.canshoot = 0; // 0 ball in ground
            this.angle=0;
                             // 1 space pressed
                             // 2 ball in shooting
            this.velocity = new THREE.Vector3();
            this.anglevelocity = 0;
            
            let ballTexture = new THREE.TextureLoader().load('img/ballTexture.jpg');

            let sphere = new THREE.SphereGeometry(10, 10, 36);
            let material1 = new THREE.MeshPhongMaterial({ map: ballTexture });

            this.object = new THREE.Mesh(sphere, material1);
            console.log(this.object);
            this.object.name="ball";
            this.object.receiveShadow = true;
            this.object.castShadow = true;
            this.object.position.set(0, 15, 100);

            renderer.shadowMap.enabled = true;
            scene.add(this.object);
//            collidableMeshList.push(this.object);
        }
        let Robot = function(){
            let model = this;
            this.Speed=100.0;
            this.fast  = false;
            this.RotationSpeed=1.5;
            this.moveForward = false;
            this.moveBackward = false;
            this.moveLeft = false;
            this.moveRight = false;

            this.angle=2;
            this.velocity = new THREE.Vector3();
            this.anglevelocity = 0;
            
            this.mixer=null;
            this.object = null;
            this.activeAction=null;
            this.previousAction=null;
            this.ready=false;
            let loader = new THREE.GLTFLoader();            
            let states = [ 'Idle', 'Walking', 'Running', 'Dance', 'Death', 'Sitting', 'Standing','Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp' ];
            this.actions = {};
            loader.load('models/RobotExpressive/RobotExpressive.glb', function (gltf) {
                gltf.scene.traverse( function( node ) {
                 if ( node instanceof THREE.Mesh ) { node.castShadow = true; }
                } );
                model.object = gltf.scene.children[0];
              //  console.log(gltf);

                model.mixer = new THREE.AnimationMixer( model.object );
                let animations=gltf.animations;
				for ( let i = 0; i < animations.length; i++ ) {
					let clip = animations[ i ];
					let action = model.mixer.clipAction( clip );
					model.actions[ clip.name ] = action;
					if ( states.indexOf( clip.name ) >= 4 ) {
							action.clampWhenFinished = true;
							action.loop = THREE.LoopOnce;
					}
				}
                model.previousAction = model.actions['Idle'];
                model.activeAction = model.actions['Idle'];
                model.activeAction.play();
                model.object.scale.set(15,15,15);
                model.object.position.set(-50,0,100);
                model.object.rotation.set(0,model.angle,0);
                scene.add( model.object );
//                collidableMeshList.push(model.object);
                model.ready=true;
            });
            this.fadeToAction = function( name, duration ) {
				this.activeAction = this.actions[ name ];
				if (this.previousAction !== this.activeAction ) {
					this.previousAction.fadeOut( duration ).stop();
                    this.activeAction
                        .reset()
                        .setEffectiveTimeScale( 1 )
                        .setEffectiveWeight( 1 )
                        .fadeIn( duration )
                        .play();
				}
				this.previousAction = this.activeAction;
			}
        }
        let human = function(){
            let model=this;
            this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            this.camera.position.set(0,50,-950);
            this.camera.lookAt(new THREE.Vector3(0,0,0));
            let loader = new THREE.GLTFLoader();
            this.object=null;
            this.ready=false;
            loader.load('models/Human/Animated Human.glb',function (gltf){
                gltf.scene.traverse( function( node ) {
                    if ( node instanceof THREE.Mesh ) { node.castShadow = true; }
                } );
                model.object = gltf.scene.children[0].children[0];
                model.object.material=new THREE.MeshPhongMaterial({color:0x525252})
                model.object.scale.set(15, 15, 15);
                model.object.position.set(0, 0, -850);
                scene.add(model.object);
                collidableMeshList.push(model.object);
              //  console.log(gltf);
                model.ready=true;
            });
        }
        let directlight = function(x,y,z){
            this.object = new THREE.DirectionalLight(0xcfcbcf, 1);
            this.object.castShadow = true;
            const d = 700;
            this.object.shadowCameraLeft = -d;
            this.object.shadowCameraRight = d;
            this.object.shadowCameraTop = d;
            this.object.shadowCameraBottom = -d;
            this.object.shadowCameraFar = far;

            this.object.shadow.mapSize.width = 1024;
            this.object.shadow.mapSize.height = 1024;
            this.object.position.set(x,y,z);

            scene.add(this.object);
        }
        let View  = function(){
            this.model = new THREE.Object3D();

            this.plane = new Plane(1024*4,1024*2);
            this.model.add(this.plane.object);

            this.wall = new Wall(1024*4,200,1024*2);
            this.model.add(this.wall.object);
            collidableMeshList.push(this.wall.object);
            this.fence = new Fence(512, 512,512);
            this.model.add(this.fence.object);
            collidableMeshList.push(this.fence.object);
            scene.add(this.model);
        }

        init();
        animate();
        function init() {
            width = window.innerWidth;
            height = window.innerHeight;
            fov = 50;
            aspect = width / height;
            near = 1;
            far = 4000;
            scene = new THREE.Scene();
            camera1 = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera1.position.set(-350,150,250);
            camera1.lookAt(new THREE.Vector3(0,0,0));

            camera=camera1;

            //controls = new THREE.PointerLockControls( camera );

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setClearColor(0xfff6e6);
            container = document.getElementById('scene');
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', function () { renderer.render(scene, camera); });
//            controls.enableDdancing_stormtrooperPI / 2) - 0.1;

            initview();
            Loadcharcters();
            lighting();
            ball = new Ball();
            initSky();
            dome =new Dome();
            
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('keypress', onKeyPress, false);
            clock = new THREE.Clock();
        }
        function initview(){
            view = new View();
        }
        function initSky() {
            // Add Sky
            sky = new THREE.Sky();
            sky.scale.setScalar(450000);
            sky.position.z = -100;
            scene.add(sky);
            // Add Sun Helper
            sunSphere = new THREE.Mesh(
                new THREE.SphereBufferGeometry(20000, 16, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            sunSphere.position.y = - 7000000;
            sunSphere.visible = true;
            scene.add(sunSphere);
            /// GUI
            var effectController = {
                turbidity: 10,
                rayleigh: 2,
                mieCoefficient: 0.005,
                mieDirectionalG: 0.8,
                luminance: 1,
                inclination: 0, // elevation / inclination
                azimuth: 0.25, // Facing front,
                sun: ! true,
                supervisorView: ! true
            };
            var distance = 400000;
            function guiChanged() {
                var uniforms = sky.material.uniforms;
                uniforms.turbidity.value = effectController.turbidity;
                uniforms.rayleigh.value = effectController.rayleigh;
                uniforms.luminance.value = effectController.luminance;
                uniforms.mieCoefficient.value = effectController.mieCoefficient;
                uniforms.mieDirectionalG.value = effectController.mieDirectionalG;
                var theta = Math.PI * (effectController.inclination - 0.5);
                var phi = 2 * Math.PI * (effectController.azimuth - 0.5);
                sunSphere.position.x = distance * Math.cos(phi);
                sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
                sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
                sunSphere.rotation.y += 50;
                sunSphere.visible=effectController.sun;
                if(effectController.supervisorView){
                    camera=supervisor.camera;
                }
                else{
                    camera=camera1;
                }
                uniforms.sunPosition.value.copy(sunSphere.position);
                renderer.render(scene, camera);
            }
            var gui = new dat.GUI();
            gui.add(effectController, "turbidity", 1.0, 20.0, 0.1).onChange(guiChanged);
            gui.add(effectController, "rayleigh", 0.0, 4, 0.001).onChange(guiChanged);
            gui.add(effectController, "mieCoefficient", 0.0, 0.1, 0.001).onChange(guiChanged);
            gui.add(effectController, "mieDirectionalG", 0.0, 1, 0.001).onChange(guiChanged);
            gui.add(effectController, "luminance", 0.0, 2).onChange(guiChanged);
            gui.add(effectController, "inclination", 0, 1, 0.0001).onChange(guiChanged);
            gui.add(effectController, "azimuth", 0, 1, 0.0001).onChange(guiChanged);
            gui.add(effectController, "sun").onChange(guiChanged);
            gui.add(effectController, "supervisorView").onChange(guiChanged);
            guiChanged();
        }

        function lighting() {
            let x=1024;
            let y=200;
            let z=512;

            let Directlight1 = new directlight(-x, y, -z);
            let Directlight2 = new directlight( x, y, -z);
            let Directlight3 = new directlight(-x, y,  z);
            let Directlight4 = new directlight( x, y,  z);
            scene.add(new THREE.HemisphereLight(0xffff0b, 0x080820, 0.5));
//            scene.add(new THREE.AmbientLight(0xa59f75, 0.6));
        }
        function Loadcharcters() {
            player = new Robot();
            supervisor = new human();
        }


        function onWindowResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            aspect = width / height;

            renderer.setSize(width, height);
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        }

        function handlemoves(){
            if(! ready) return;
            let playermove=player.moveBackward || player.moveForward || player.moveLeft ||player.moveRight;
            if(playermove){
                if(player.fast)
                    player.fadeToAction('Running',0.2);
                else
                    player.fadeToAction('Walking',0.2);
            }
            else{
                player.fadeToAction('Idle',0.2);
            }
        }
        function onKeyDown(event) {
            switch (event.keyCode) {
                case keyup: // w
                    player.moveForward = true;
                    break;
                case keyleft: // a
                    player.moveLeft = true;
                    break;

                case keydown: // s
                    player.moveBackward = true;
                    break;

                case keyright: // d
                    player.moveRight = true;
                    break;
                case keyspeed:
                    if(! player.fast){
                        player.fast=true;
                        player.Speed*=3;
                    }
                    break;
                case 32: // space
                    if(ball.canshoot == 0)
                        ball.canshoot = 1;
                    break;
            }
            handlemoves();

        }

        function onKeyUp(event) {
            switch (event.keyCode) {
                case keyup: // w
                    player.moveForward = false;
                    break;

//						case 37: // left
                case keyleft: // a
                    player.moveLeft = false;
                    break;

//						case 40: // down
                case keydown: // s
                    player.moveBackward = false;
                    break;
//						case 39: // right
                case keyright: // d
                    player.moveRight = false;
                    break;
                case keyspeed:
                    if(player.fast){
                        player.fast=false;
                        player.Speed/=3;
                    }
                    break;

                case 32: // space
                    break;
            }
            handlemoves();
        };

        function onKeyPress(event){
            switch(event.keyCode){
                case 32: // space
                    break;
            }
        }
        function onMouseDown(event) {
            event.preventDefault();
            mouseDown = true;
        }
        function onMouseUp(event) {
            // var time = new Date.now();
            // soccerball.position.y += time - moveDate;
            event.preventDefault();
            mouseDown = false;

        }
        function addbetween(before,change,min,max){
            return Math.min(max ,Math.max(min ,before + change));
        }
        function updatecharachter(){
            player.mixer.update( delta );
            dome.ob3mixer.update(delta);
            player.velocity.x -= player.velocity.x * 40.0 * delta;
            player.velocity.z -= player.velocity.z * 40.0 * delta;
            player.velocity.y -= 9.8 * 30.0 * delta;
            player.anglevelocity -= player.anglevelocity * 20 * delta;

            let rotationsign = Number( player.moveLeft ) - Number( player.moveRight) ;
            let directionsign =  Number( player.moveForward ) - Number( player.moveBackward );

            player.anglevelocity += rotationsign * player.RotationSpeed * delta;
            player.angle+=player.anglevelocity;

            player.velocity.x += directionsign * player.Speed * Math.sin(player.angle) * delta ;
            player.velocity.z += directionsign * player.Speed * Math.cos(player.angle) * delta ;
            if(player.ccanfly)
                player.velocity.y += player.Speed * delta ;
            player.object.position.x+=player.velocity.x;
            player.object.position.z+=player.velocity.z;

            player.object.position.y=addbetween(player.object.position.y,player.velocity.y,0,512 - 25);
            if(player.object.position.y<=0){
                player.object.position.y=0;
                player.velocity.y=0;
            }

            player.object.rotation.y = ( player.angle );
            supervisor.camera.position.x = -1 * player.object.position.x * 0.1;
            if(collisitions(player.object)){
                player.object.position.x-=player.velocity.x;
                player.object.position.z-=player.velocity.z;
            }
         }
        function dist(vertex1,vertex2){
            return Math.sqrt((vertex1.x-vertex2.x)**2 + (vertex1.y-vertex2.y)**2 +(vertex1.z-vertex2.z)**2);
        }
        function coll1(ray,object){
            var collisionResults = ray.intersectObjects( collidableMeshList ,true);
    //                console.log(collisionResults);
            for(let i=0;i<collisionResults.length;i++){
                let node = collisionResults[i];
                if(node.object === object)continue;
                if (node.distance < 20) {
                    //collision occurs
    //                        console.log("x ",ball.object.position.x);
    //                        console.log("z ",ball.object.position.z);
                            console.log(object,node);
                    //  return;
                    // break;  
                    return 1;
                }   
            }
            return 0;
        }
        function collisitions(object){
//            console.log(scene,object);
            var originPoint = object.position.clone();
            var dx=[0, 0,   0, 0,   1,-1,   0, 0,0, 0,    1,-1,1,-1,     1,-1,1,-1,     1, 1,1, 1,    1,-1,1,-1,     1,-1,1,-1,     -1, -1,-1,-1,    1,-1,1,-1,     1,-1,1,-1,];
            var dy=[0, 0,   1,-1,   0, 0,   1,-1,1,-1,    0, 0,0, 0,    -1, 1,1,-1,     1,-1,1,-1,    1, 1,1, 1,    -1, 1,1,-1,     1,-1,1,-1,    -1, -1,-1, -1,    -1, 1,1,-1,];
            var dz=[1,-1,   0, 0,   0, 0,   -1,1,1,-1,   -1, 1,1,-1,     0, 0,0, 0,     -1,1,1,-1,   -1, 1,1,-1,     1, 1,1, 1,     -1,1,1,-1,   -1, 1,1,-1,     -1, -1,-1,-1,];
            // console.log("Thhhhhhhhhhhhhhh",ball);
            for(let i=0;i<dx.length;i++){
                ray = new THREE.Raycaster( originPoint, new THREE.Vector3( dx[i] , dy[i],  dz[i] ));
                if(coll1(ray,object))return 1;
            }
            return 0;
        }
        function updateball(){
            ball.velocity.x -= ball.velocity.x * 2.0 * delta;
            ball.velocity.z -= ball.velocity.z * 2.0 * delta;
            ball.velocity.y -= 12.8 * 4.0 * delta;
            ball.anglevelocity -= ball.anglevelocity * 1.2 * delta;
            if(ball.canshoot == 1
            && dist(ball.object.position,player.object.position) <=50){
                
                ball.angle = player.angle;
                ball.anglevelocity +=ball.RotationSpeed * delta;

                ball.velocity.x += ball.Speed * Math.sin(ball.angle) * delta ;
                ball.velocity.z += ball.Speed * Math.cos(ball.angle) * delta ;
                ball.velocity.y += ball.Speed *0.8 * delta;
            }
            if(ball.canshoot==1)ball.canshoot=0;
            
            ball.object.position.x+=ball.velocity.x;
            ball.object.position.y+=ball.velocity.y;
            ball.object.position.z+=ball.velocity.z;
            
            ball.object.rotation.x+=ball.anglevelocity;
            ball.object.rotation.z+=ball.anglevelocity;
            if(ball.canshoot!=1){
                if(Math.abs(ball.velocity.x)<= eps
                && Math.abs(ball.velocity.z)<= eps
                ){
                    ball.canshoot=0;
                    ball.object.position.y=10;
                }
                if(collisitions(ball.object)){
                    ball.object.position.x-=ball.velocity.x;
//                    ball.object.position.y-=ball.velocity.y;
                    ball.object.position.z-=ball.velocity.z;
                    ball.angle+=Math.PI;
                }
            }
            if(ball.object.position.y<=10){
                ball.velocity.y = Math.max(0,ball.velocity.y);
                ball.object.position.y =10;
            }
        }
        function animate() {
            requestAnimationFrame(animate);
            delta = clock.getDelta() ;
            if (ready) {
                update();
                render();
            }
            else{
                ready=player.ready && supervisor.ready && dome.ready==dome.np;
                if(ready)console.log(scene);
            }
        }
        function update() {
            updatecharachter();
            updateball();
            camera.lookAt(player.object.position);
            supervisor.object.lookAt(player.object.position);
        }
        function render() {
            renderer.render(scene, camera);
        }
        // for any test
        function getCube() {
            shape = new THREE.Mesh(
                new THREE.BoxGeometry(100, 100, 100),
                new THREE.MeshNormalMaterial()
            );
            shape.position.set(0, 100, 0);
            scene.add(shape);
        }
    </script>
</body>

</html>
