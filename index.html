<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <title>therd test three.js app</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <div id="scene"></div>

    <script src="node_modules/three/build/three.js"></script>
    <script src="node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
    <script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
    <script src="node_modules/three/examples/js/objects/Sky.js"></script>
    <script src="node_modules/three/examples/js/libs/dat.gui.min.js"></script>
    <script src="node_modules/three/examples/js/controls/PointerLockControls.js"></script>

    <!--        <script src="node_modules/three/examples/js/loaders/OBJLoader.js"></script>-->

    <script>
        const playerSpeed = 100.0;
        const playerRotationSpeed = 1.0;
        let scene,
            renderer,
            container,
            width,
            height,
            alpha =0.5,
            i=0;
        let camera,
            controls,
            soccerball,
            fov, aspect, near, far;
        let Playermixer, clock, ready = false;
        let mouseDown = false;

        let raycaster, playerContols;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let playervelocity = 0;
        let playerangle = 0;

        let shape, shapeGeometry;

        init();

        animate();
        function init() {
            width = window.innerWidth;
            height = window.innerHeight;
            fov = 50;
            aspect = width / height;
            near = 1;
            far = 4000;
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(50, 150, -350);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            //controls = new THREE.PointerLockControls( camera );

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setClearColor(0xfff6e6);
            container = document.getElementById('scene');
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', function () { renderer.render(scene, camera); });
            controls.staticMoving = true;
            controls.minDistance = 100;
            controls.maxDistance = 500;
            controls.maxPolarAngle = (Math.PI / 2) - 0.1;
            lighting();
            plane();
            transparency();
            ball();
            wall();
            initSky();
            humantLoad();
            robotLoad();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            clock = new THREE.Clock();
        }
        function plane() {
            // A mesh is created from the geometry and material, then added to the scene
            let groundTexture = new THREE.TextureLoader().load('img/grasslight-big.jpg');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(25, 25);
            groundTexture.anisotropy = 16;
            let plane = new THREE.Mesh(
                new THREE.PlaneGeometry(3000, 2000),
                new THREE.MeshStandardMaterial({
                    map: groundTexture,
                })
            );
            plane.rotateX(-Math.PI / 2);
            plane.receiveShadow = true;
            plane.castShadow = true;
            scene.add(plane);
        }
        function transparency() {

            let geometry = new THREE.BoxGeometry(200, 200, 2);
            //geometry.computeLineDistances();
            let material = new THREE.MeshStandardMaterial({
                opacity: 0.5,
                transparent: true,
                color: 0x0000ff
            });
            let mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -100.0;
            scene.add(mesh);
        }
        function ball() {
            let ballTexture = new THREE.TextureLoader().load('img/ballTexture.jpg');

            let sphere = new THREE.SphereGeometry(10, 10, 36);
            let material1 = new THREE.MeshLambertMaterial({ map: ballTexture });

            soccerball = new THREE.Mesh(sphere, material1);
            soccerball.receiveShadow = true;
            soccerball.castShadow = true;
            soccerball.position.y += 50;
            soccerball.position.z += 200;
            soccerball.position.set(0, 15, 100);

            renderer.shadowMap.enabled = true;
            scene.add(soccerball);
        }
        function wall() {
            let skyBox = new THREE.BoxGeometry(3000, 1000, 2000);
            let materials =
                [
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('img/footballwall.jpg'), side: THREE.DoubleSide }),
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('img/footballwall.jpg'), side: THREE.DoubleSide }),
                    new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, wireframe: true, side: THREE.DoubleSide }),
                    new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, wireframe: true, side: THREE.DoubleSide }),
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('img/footballwall.jpg'), side: THREE.DoubleSide }),
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('img/footballwall.jpg'), side: THREE.DoubleSide }),
                    //                    new THREE.MeshBasicMaterial( { transparent: true, opacity: 0, wireframe: true, side: THREE.DoubleSide} ),
                ]
            let faceMaterial = new THREE.MeshFaceMaterial(materials);
            let skyBoxMesh = new THREE.Mesh(skyBox, faceMaterial);
            skyBoxMesh.position.y = 400;
            scene.add(skyBoxMesh);
        }
        function initSky() {
            // Add Sky
            sky = new THREE.Sky();
            sky.scale.setScalar(450000);
            sky.position.z = -100;
            scene.add(sky);
            // Add Sun Helper
            sunSphere = new THREE.Mesh(
                new THREE.SphereBufferGeometry(20000, 16, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            sunSphere.position.y = - 700000;
            sunSphere.visible = true;
            scene.add(sunSphere);
            /// GUI
            var effectController = {
                turbidity: 10,
                rayleigh: 2,
                mieCoefficient: 0.005,
                mieDirectionalG: 0.8,
                luminance: 1,
                inclination: 0.49, // elevation / inclination
                azimuth: 0.25, // Facing front,
                sun: ! true
            };
            var distance = 400000;
            function guiChanged() {
                var uniforms = sky.material.uniforms;
                uniforms.turbidity.value = effectController.turbidity;
                uniforms.rayleigh.value = effectController.rayleigh;
                uniforms.luminance.value = effectController.luminance;
                uniforms.mieCoefficient.value = effectController.mieCoefficient;
                uniforms.mieDirectionalG.value = effectController.mieDirectionalG;
                var theta = Math.PI * (effectController.inclination - 0.5);
                var phi = 2 * Math.PI * (effectController.azimuth - 0.5);
                sunSphere.position.x = distance * Math.cos(phi);
                sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
                sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
                sunSphere.rotation.y += 50;
                sunSphere.visible = effectController.sun;
                uniforms.sunPosition.value.copy(sunSphere.position);
                renderer.render(scene, camera);
            }
            var gui = new dat.GUI();
            gui.add(effectController, "turbidity", 1.0, 20.0, 0.1).onChange(guiChanged);
            gui.add(effectController, "rayleigh", 0.0, 4, 0.001).onChange(guiChanged);
            gui.add(effectController, "mieCoefficient", 0.0, 0.1, 0.001).onChange(guiChanged);
            gui.add(effectController, "mieDirectionalG", 0.0, 1, 0.001).onChange(guiChanged);
            gui.add(effectController, "luminance", 0.0, 2).onChange(guiChanged);
            gui.add(effectController, "inclination", 0, 1, 0.0001).onChange(guiChanged);
            gui.add(effectController, "azimuth", 0, 1, 0.0001).onChange(guiChanged);
            gui.add(effectController, "sun").onChange(guiChanged);
            guiChanged();
        }
        function lighting() {
            const light = new THREE.DirectionalLight(0xdfebff, 1);
            light.position.set(-400, 1000, -400);
            light.castShadow = true;
            const d = 200;
            light.shadowCameraLeft = -d;
            light.shadowCameraRight = d;
            light.shadowCameraTop = d;
            light.shadowCameraBottom = -d;
            light.shadowCameraFar = far;
            scene.add(light);
            scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 0.6));
            scene.add(new THREE.AmbientLight(0xa59f75, 0.6));
        }
        let Player;
        function robotLoad() {
            let loader = new THREE.GLTFLoader();
            loader.load('RobotExpressive/RobotExpressive.glb', function (gltf) {
                let object = gltf.scene;
                console.log(scene);
                object.scale.set(10, 10, 10);
                object.position.set(-40, 0, 20);
                object.rotation.set(0, 0.4, 0);
                Playermixer = new THREE.AnimationMixer(object);
                console.log(gltf.animations.length);
                let walk;
                for (let i = 0; i < gltf.animations.length; i++) {
                     clip = gltf.animations[i];
                    if (clip.name === 'Walking') {
                        console.log("found");
                        walk = clip;
                    }
                }
                action = Playermixer.clipAction(walk);
                playerContols = new THREE.PointerLockControls(object.getObjectByName('Root Scene'));
                scene.add(playerContols.getObject());
                ready = true;
                console.log(object);
            });
        }
        function humantLoad() {
            let loader = new THREE.GLTFLoader();
            loader.load('Animated Human by @Quaternius/Animated Human.glb', function (gltf) {
                let object = gltf.scene;
                let walk;
                console.log(gltf.animations.length);
                for (let i = 0; i < gltf.animations.length; i++) {
                    let clip = gltf.animations[i];
                    console.log(clip.name);
                    if (clip.name === 'Walking') {
                        console.log("found");
                        walk = clip;
                    }
                }
                object.scale.set(10, 10, 10);
                object.position.set(40, 0, 20);
                object.rotation.set(0, -0.4, 0);
                scene.add(object);
            });
        }

        function onWindowResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            aspect = width / height;

            renderer.setSize(width, height);
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        }

        function onKeyDown(event) {
            action.play();
            switch (event.keyCode) {
                //						case 38: // up
                case 87: // w
                    moveForward = true;
                    break;
                //						case 37: // left
                case 65: // a
                    moveLeft = true;
                    break;
                //						case 40: // down
                case 83: // s
                    moveBackward = true;
                    break;
                //						case 39: // right
                case 68: // d
                    moveRight = true;
                    break;
                case 32: // space
                    break;
            }
        };

        function onKeyUp(event) {
            action.stop();
            switch (event.keyCode) {
                //						case 38: // up
                case 87: // w
                    moveForward = false;
                    break;
                //						case 37: // left
                case 65: // a
                    moveLeft = false;
                    break;
                //						case 40: // down
                case 83: // s
                    moveBackward = false;
                    break;
                //						case 39: // right
                case 68: // d
                    moveRight = false;
                    break;
            }
        };
        function onMouseDown(event) {
            event.preventDefault();
            mouseDown = true;



        }
        function onMouseUp(event) {
            // var time = new Date.now();
            // soccerball.position.y += time - moveDate;
            event.preventDefault();
            mouseDown = false;

        }


        function animate() {
            requestAnimationFrame(animate);
            if (ready) {
                update();
                render();
            }
        }
        function update() {
            delta = clock.getDelta();
            Playermixer.update(delta);

            playervelocity = 0;

            let playerdirection = new THREE.Vector3();
            playerdirection.x = Number(moveLeft) - Number(moveRight);
            playerdirection.z = Number(moveForward) - Number(moveBackward);
            playerdirection.normalize(); // this ensures consistent movements in all directions
            let sign = playerdirection.x;
            playerangle += sign * playerRotationSpeed * delta;

            if (moveForward || moveBackward) playervelocity += playerdirection.z * playerSpeed * delta;
            //                if ( moveLeft || moveRight ) playervelocity.x += playerdirection.x * 400.0 * delta;

            let x = playerContols.getObject().position.x;
            let y = playerContols.getObject().position.y;
            let z = playerContols.getObject().position.z;
            //                console.log(playervelocity);
            x = Math.min(1400, Math.max(-1400, x + playervelocity * Math.sin(playerangle)));
            z = Math.min(900, Math.max(-900, z + playervelocity * Math.cos(playerangle)));
            playerContols.getObject().position.set(x, y, z);

            playerContols.getObject().rotation.y = (playerangle);

            camera.lookAt(playerContols.getObject().position);


            if (mouseDown) {
                i += 3;

            }
            if (!mouseDown) {


                soccerball.position.x = i;
                soccerball.position.y = (10 * Math.sqrt(soccerball.position.x) / Math.sqrt(Math.cos(2 * alpha)) + soccerball.position.x * Math.tan(alpha)) * 0.1;
            }


        }
        function render() {
            renderer.render(scene, camera);
        }
        // for any test
        function getCube() {
            shape = new THREE.Mesh(
                new THREE.BoxGeometry(100, 100, 100),
                new THREE.MeshNormalMaterial()
            );
            shape.position.set(0, 100, 0);
            scene.add(shape);
        }
    </script>
</body>

</html>